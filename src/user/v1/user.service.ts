import {
  BadRequestException,
  HttpStatus,
  Injectable,
  NotFoundException,
  UnauthorizedException,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { User } from '../../schema/user.schema';
import { LoginUserDto, RegisterUserDto } from '../../dto';
import {
  AVAILABLE_USER_ROLES,
  USER_LOGIN_TYPE,
} from '../../constants/appConstants.json';
import {
  emailVerificationMailgenContent,
  forgotPasswordMailgenContent,
  sendVerificationEmail,
} from 'src/utils/mail';
import { Request } from 'express';
import { UserHandlers } from 'src/handlers/userHandlers.service';
import { setCookies } from 'src/utils/cookies';
import * as crypto from 'crypto';

@Injectable()
export class UserService {
  constructor(
    @InjectModel(User.name) private userModel: Model<User>,
    private userHandlers: UserHandlers,
  ) {}

  async registerUser(req: Request, data: RegisterUserDto): Promise<User> {
    const { email, username, password, role } = data;

    // Check if user with the same email or username already exists
    const existingUser = await this.userModel.findOne({
      $or: [{ username }, { email }],
    });
    if (existingUser) {
      throw {
        message: 'User with email or username already exists',
        status: HttpStatus.CONFLICT,
      };
    }

    // Create new user
    const newUser = await this.userModel.create({
      email,
      username,
      password,
      isEmailVerified: false,
      role: role || AVAILABLE_USER_ROLES.USER,
    });

    // Generate temporary token for email verification
    const { unHashedToken, hashedToken, tokenExpiry } =
      newUser.generateTemporaryToken();

    // Assign hashedToken and tokenExpiry in DB
    newUser.emailVerificationToken = hashedToken;
    newUser.emailVerificationExpiry = tokenExpiry;
    await newUser.save({ validateBeforeSave: false });

    // Send verification email
    await sendVerificationEmail({
      email: email,
      subject: 'Please verify your email',
      mailgenContent: emailVerificationMailgenContent({
        username,
        verificationUrl: `${process.env.CLIENT_URL}/v1/users/verifyVerificationEmail/${unHashedToken}`,
      }),
    });

    // Omit sensitive fields from the response
    return newUser.toObject({
      transform: (doc, ret) => {
        delete ret.password;
        delete ret.refreshToken;
        delete ret.emailVerificationToken;
        delete ret.emailVerificationExpiry;
        return ret;
      },
    });
  }

  async loginUser(
    loginUserDto: LoginUserDto,
    res: any,
  ): Promise<{ user: User; accessToken: string; refreshToken: string }> {
    const { usernameOrEmail, password } = loginUserDto;

    // Find user by username or email
    const user: User = await this.userModel.findOne({
      $or: [{ username: usernameOrEmail }, { email: usernameOrEmail }],
    });

    if (!user) {
      throw new NotFoundException('User not found');
    }

    if (user.loginType !== USER_LOGIN_TYPE.EMAIL_PASSWORD) {
      throw new BadRequestException(
        'You have previously registered using ' +
          user.loginType?.toLowerCase() +
          '. Please use the ' +
          user.loginType?.toLowerCase() +
          ' login option to access your account.',
      );
    }

    // Check if the provided password matches the stored password
    const isPasswordValid = await user.isPasswordCorrect(password);

    if (!isPasswordValid) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const { accessToken, refreshToken } =
      await this.userHandlers.generateAccessAndRefreshTokens(user._id);
    console.log('accessToken', accessToken);
    console.log('refreshToken', refreshToken);

    const loggedInUser = await this.userModel
      .findById(user._id)
      .select(
        '-password -refreshToken -emailVerificationToken -emailVerificationExpiry',
      );

    const cookieOptions = {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
    };

    setCookies(
      res,
      {
        accessToken,
        refreshToken,
      },
      cookieOptions,
    );

    return { user: loggedInUser, accessToken, refreshToken };
  }

  async verifyEmail(verificationToken: string): Promise<any> {
    if (!verificationToken) {
      throw new Error('Email verification token is missing');
    }

    // Generate a hash from the token that we are receiving
    const hashedToken = crypto
      .createHash('sha256')
      .update(verificationToken)
      .digest('hex');

    // Find user with the hashed token generated by received token
    // Also check if token expiry is greater than current time
    const user = await this.userModel.findOne({
      emailVerificationToken: hashedToken,
      emailVerificationExpiry: { $gt: Date.now() },
    });

    if (!user) {
      throw new Error('Token is invalid or expired');
    }

    // Update user details
    user.emailVerificationToken = undefined;
    user.emailVerificationExpiry = undefined;
    user.isEmailVerified = true;
    await user.save({ validateBeforeSave: false });

    return { isEmailVerified: true, message: 'Email is verified' };
  }

  async refreshAccessToken(refreshToken: string): Promise<any> {
    try {
      const decodedToken = this.userHandlers.verifyRefreshToken(refreshToken);
      const user = await this.userModel.findOne({ _id: decodedToken._id });

      if (!user) {
        throw new BadRequestException('User not found');
      }

      if (refreshToken !== user?.refreshToken) {
        throw new UnauthorizedException('Invalid refresh token');
      }

      const { accessToken, refreshToken: newRefreshToken } =
        await this.userHandlers.generateAccessAndRefreshTokens(user._id);

      return { accessToken, refreshToken: newRefreshToken };
    } catch (error) {
      throw new UnauthorizedException('Invalid refresh token');
    }
  }

  async forgotPassword(email: string): Promise<any> {
    const user = await this.userModel.findOne({ email });

    if (!user) {
      throw new NotFoundException('User not found');
    }

    const { unHashedToken, hashedToken, tokenExpiry } =
      user.generateTemporaryToken();

    user.forgotPasswordToken = hashedToken;
    user.forgotPasswordExpiry = tokenExpiry;
    await user.save({ validateBeforeSave: false });

    // Send password reset email
    await sendVerificationEmail({
      email: email,
      subject: 'Password Reset',
      mailgenContent: forgotPasswordMailgenContent({
        username: user.username,
        resetPasswordUrl: `${process.env.CLIENT_URL}/v1/users/resetPassword/${unHashedToken}`,
      }),
    });

    return { message: 'Password reset email sent' };
  }

  async resetPassword(resetToken: string, newPassword: string): Promise<any> {
    try {
      const hashedToken = crypto
        .createHash('sha256')
        .update(resetToken)
        .digest('hex');

      const user = await this.userModel.findOne({
        forgotPasswordToken: hashedToken,
        forgotPasswordExpiry: { $gt: Date.now() },
      });

      if (!user) {
        throw new BadRequestException('Invalid or expired reset token');
      }

      user.password = newPassword;
      user.forgotPasswordToken = undefined;
      user.forgotPasswordExpiry = undefined;
      await user.save({ validateBeforeSave: false });

      return { message: 'Password reset successfully' };
    } catch (error) {
      throw new BadRequestException('Invalid or expired reset token');
    }
  }

  async logoutUser(userId: string, res: any): Promise<any> {
    await this.userHandlers.clearRefreshToken(userId);
    const options = {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
    };

    res.clearCookie('accessToken', options);
    res.clearCookie('refreshToken', options);

    return { message: 'User logged out successfully' };
  }
}
